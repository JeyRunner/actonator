
#pragma once

/**
 * THIS FILE IS AUTOGENERATED, DO NOT EDIT!
 * Generated by command 'canSotCli genCode -f motorControllerCanProtocol.def.yaml -o src/can_master_lib/protocol_generated/ --master '.
 * For the master.
 */

#include "objectTree/OTNodeValueTypeDefs.h"
#include "objectTree/OTDeclares.h"
#include "objectTree/ProtocolDef.h"
#include "remoteCalls/RemoteCalls.h"

namespace MotorControllerCanProtocolNamespace {

enum class MOTOR_OPERATION_MODE {
	CONFIGURATION_PROCESS = 3,
	CONTROL_PD = 2,
	DO_NOTHING = 0,
};
enum class REQUEST_MOTOR_OPERATION_MODE {
	CONTROL_PD = 2,
	DO_NOTING = 0,
};
enum class REQUEST_MOTOR_OPERATION_MODE_ERROR {
	MOTOR_NOT_CONFIGURED = 0,
};
enum class MOTOR_ENABLED {
	DISABLED = 1,
	ENABLED = 0,
};
enum class MOTOR_CONFIG_DIRECTION {
	INVERSE = 1,
	NORMAL = 0,
};
enum class BOOL {
	FALSE = 0,
	TRUE = 1,
};




struct StartMotorInitSequenceArgDataCaller: RemoteCallDataWritable {
	TYPE_UINT16 throttle;


  StartMotorInitSequenceArgDataCaller(TYPE_UINT16 throttle): throttle(throttle) {}
  StartMotorInitSequenceArgDataCaller() = default;

  const uint8_t getRequiredDataSizeBytes() final {
    return sizeof(TYPE_UINT16);
  }

  /**
   * Write value to data of a can frame.
   */
  inline void _writeToData(uint8_t *data) final {
 		writeToDataUINT16(data[0], throttle);

  }
};

struct StartMotorInitSequenceReturnDataCaller: RemoteCallDataReadable {
	TYPE_F32 motorAlignmentOffset;
	TYPE_UINT8 electricalRotationsPerRevolution;
	MOTOR_CONFIG_DIRECTION motorDirection;


  StartMotorInitSequenceReturnDataCaller(TYPE_F32 motorAlignmentOffset,TYPE_UINT8 electricalRotationsPerRevolution,MOTOR_CONFIG_DIRECTION motorDirection): motorAlignmentOffset(motorAlignmentOffset), electricalRotationsPerRevolution(electricalRotationsPerRevolution), motorDirection(motorDirection) {}
  StartMotorInitSequenceReturnDataCaller() = default;

  const uint8_t getRequiredDataSizeBytes() final {
    return sizeof(TYPE_F32) + sizeof(TYPE_UINT8) + sizeof(uint8_t);
  }

  /**
   * Read value from data of a can frame.
   * This will overwrite the current value of the node.
   * This will also set the wasChangedEvent to true.
   */
  inline void _readFromData(const uint8_t *data) final {
 		readFromDataF32(data[0], motorAlignmentOffset);
		readFromDataUINT8(data[sizeof(TYPE_F32)], electricalRotationsPerRevolution);
		readFromDataENUM(data[sizeof(TYPE_F32) + sizeof(TYPE_UINT8)], motorDirection);

  }
};


struct SetMotorParametersArgDataCaller: RemoteCallDataWritable {
	TYPE_INT16 encoderElectricalOffset;
	TYPE_UINT8 electricalRotationsPerRevolution;
	MOTOR_CONFIG_DIRECTION motorDirection;


  SetMotorParametersArgDataCaller(TYPE_INT16 encoderElectricalOffset,TYPE_UINT8 electricalRotationsPerRevolution,MOTOR_CONFIG_DIRECTION motorDirection): encoderElectricalOffset(encoderElectricalOffset), electricalRotationsPerRevolution(electricalRotationsPerRevolution), motorDirection(motorDirection) {}
  SetMotorParametersArgDataCaller() = default;

  const uint8_t getRequiredDataSizeBytes() final {
    return sizeof(TYPE_INT16) + sizeof(TYPE_UINT8) + sizeof(uint8_t);
  }

  /**
   * Write value to data of a can frame.
   */
  inline void _writeToData(uint8_t *data) final {
 		writeToDataINT16(data[0], encoderElectricalOffset);
		writeToDataUINT8(data[sizeof(TYPE_INT16)], electricalRotationsPerRevolution);
		writeToDataENUM(data[sizeof(TYPE_INT16) + sizeof(TYPE_UINT8)], motorDirection);

  }
};


struct ChangeMotorOperationModeArgDataCaller: RemoteCallDataWritable {
	REQUEST_MOTOR_OPERATION_MODE requestedOperationMode;


  ChangeMotorOperationModeArgDataCaller(REQUEST_MOTOR_OPERATION_MODE requestedOperationMode): requestedOperationMode(requestedOperationMode) {}
  ChangeMotorOperationModeArgDataCaller() = default;

  const uint8_t getRequiredDataSizeBytes() final {
    return sizeof(uint8_t);
  }

  /**
   * Write value to data of a can frame.
   */
  inline void _writeToData(uint8_t *data) final {
 		writeToDataENUM(data[0], requestedOperationMode);

  }
};



}
